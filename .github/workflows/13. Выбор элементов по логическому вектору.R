# --------
# Потанин Богдан Станиславович
# Введение в R :)
# Урок 13. Выбор элементов по логическому вектору
# --------


# Рассмотрим способ обращения 
# к элементам вектора
v_1 <- c(1, 2, 3, 4, 5)                       # создаем вектор
b_1 <- c(TRUE, FALSE, TRUE, FALSE, FALSE)     # создаем вектор из bool'ов
v_1[b_1]                                      # выбираем значения v_1
                                              # для которых b_1 равен TRUE
v_2 <- c(6, 7, 8, 9, 10)                      # другой вектор
(v_2 > 7)                                     # логическое выражение 
                                              # вернуло вектор bool'ов
v_1[v_2 > 7]                                  # выбираем элементы v_1, 
                                              # для которых
                                              # соответствующие элементы 
                                              # v_2 больше 7

# Еще несколько примеров
v_1[v_1 <= 2]
v_1[(v_1* 3) > v_2]

# Теперь поработаем с датафреймом
d <- data.frame("Some_Variable"=c(1, 7, 1, -5 ,6), 
                "Other_Variable" = c(10, 3, 5, 15, 32))
# Выберем только те строки, где все значения больше 1
d[(d[, 1] > 1) & (d[, 2] > 1),]
# Выберем строки в зависимости от условия 
# на вектор такой же длины, как и у d
d[v_2>7, ]
d[b_1, ]

# Часто данный способ обращения используется для того,
# чтобы заменить какие-то элементы, удовлетворяющие
# определенному условию
d[d[, 1] > 5, 1] <- 10              # заменим на 10 элементы первого
                                    # столбца d, которые больше 5
v_1[v_1 <= 3] <- v_2[v_1 <= 3]      # элементы v_1, которые не превышают 3,
                                    # заменим на соответствующие элементы v_2

# Отбор по логическому условию можно осуществлять не
# только с помощью логических векторов, но и через
# выбор индексов строк, удовлетворяющих определенному
# условию
# Функция which() позволяет найти индексы элементов,
# удовлетворяющих определенному условию
cond_1 <- which(v_1 > 6)                # индексы v_1, которым соответствуют
                                        # элементы, значения которых
                                        # превышают 6
print(v_1)
print(v_1[cond_1])
cond_2 <- which(d$Some_Variable > 1)    # индексы столбца Some_Variable, 
                                        # датафрейма d, которые соответствуют
                                        # элементам, значения которых
                                        # превышают 1
print(d)
print(d[cond_2, ])

  # ЗАДАНИЯ
    # 1. Напишите функцию, которая принимает два вектора и
    #    возвращает вектор, состоящий из элементов первого
    #    вектора, которые больше, чем соответствующие 
    #    элементы второго вектора
{
  myFunc <- function(x, y)
  {
    if(length(x) != length(y))
    {
      stop("x and y should be vectors of the same size")
    }
    
    cond <- x > y
    return(x[cond])
  }
  myFunc(x = c(1, 2, 3, 4, 5), 
         y = c(-1, 5, 2, 3, 8))
}
    # 2. Напишите функцию, которая принимает два строковых вектора
    #    и возвращает вектор, элементы которого содержат строки,
    #    попарно повторяющиеся у обоих векторов
{
  myFunc <- function(x, y)
  {
    if(length(x) != length(y))
    {
      stop("x and y should be vectors of the same size")
    }
    
    cond <- x == y
    return(x[cond])
  }
  myFunc(x = c("cat", "dog", "bird", "fish", "lion"), 
         y = c("cat", "dog", "snake", "hamster", "lion"))
}
    # 3. Напишите функцию, которая принимает два вектора и возвращает
    #    третий вектор, i-й элемент которого равняется наибольшему
    #    из i-х элементов соответствующих векторов
{
  myFunc <- function(x, y)
  {
    if(length(x) != length(y))
    {
      stop("x and y should be vectors of the same size")
    }
    
    z <- x               # пусть для начала z и x совпадают
    cond <- x <= y       # создаем вектор условия x <= y
    z[cond] <- y[cond]   # где это условие соблюдается,
                         # меняем x на y
    return(z)
  }
  myFunc(x = c(1, 2, 3, 4, 5),
         y = c(-1, 5, 0, 3, 10))
}
    # 4. Повторите предыдущий пункт для трех векторов
{
  myFunc <- function(x, y, t)
  {
    if((length(x) != length(y)) | (length(x) != length(t)))
    {
      stop("x, y and t should be vectors of the same size")
    }
    
    z <- x                  # пусть для начала z и x совпадают
    cond_1 <- z <= y        # создаем вектор условия z <= y
    z[cond_1] <- y[cond_1]  # где это условие соблюдается
                            # меняем z на y
    cond_1 <- z <= t        # повторяем еще раз для t
    z[cond_1] <- t[cond_1]

    return(z)
  }
  myFunc(x = c(1, 2, 3, 4, 5),
         y = c(-1, 5, 0, 3, 10),
         t = c(5, 3, 6, 1, 2))
}
    # 5. Напишите функцию, которая принимает три вектора и возвращает
    #    вектор, состоящий из элементов первого вектора, которые
    #    превышают и сумму и произведение элементов второго и
    #    третьего векторов
{
  myFunc <- function(x, y, t)
  {
    if((length(x) != length(y)) | (length(x) != length(t)))
    {
      stop("x, y and t should be vectors of the same size")
    }
    
    cond <- (x > (y + t)) & (x > (y * t))
    z <- x[cond]
    
    return(z)
  }
  myFunc(x = c(8, 12, 5, 2, 25),
         y = c(-1, 5, 0, 3, 10),
         t = c(5, 3, 6, 1, 2))
}
    # 6. Создайте функцию, которая принимает датафрейм, 
    #    и возвращает его удалив строки, в которых сумма 
    #    элементов первых двух столбцов меньше суммы
    #    элементов последних двух столбцов.
{
  myFunc <- function(x)
  {
    if(dim(x)[2] != 3)
    {
      stop("x should be dataframe with 3 columns")
    }
    
    cond <- (x[, 1] + x[, 2]) < (x[, 2] + x[, 3])
    x <- x[!cond, ]
    
    return(x)
  }
  
  x <- data.frame("a" = c(8, 12, 5, 2, 25),
                  "b" = c(-1, 5, 0, 3, 10),
                  "c" = c(5, 3, 6, 9, 2))
  myFunc(x)
  
}
    # 7. Создайте функцию, которая принимает датафрейм и строку.
    #    Функция должна возвращать датафрейм, у которого в столбце,
    #    название которого совпадает со строкой, все отрицательные
    #    значения заменены на 0. При этом если имени, указанного
    #    в строке, не существует в столбце, то функция должна
    #    возвращать ошибку при помощи функции stop().
{
  myFunc <- function(x, s)
  {
    cond_1 <- names(x) == s
    
    if(!any(cond_1))
    {
      stop("There is not column s in x")
    }
    
    x[x[, cond_1] < 0, cond_1] <- 0
    
    return(x)
  }
  
  x <- data.frame("a" = c(8, 12, 5, 2, 25),
                  "b" = c(-1, 5, 0, -3, 10),
                  "c" = c(5, 3, 6, 9, 2))
  myFunc(x, "b")
  
}