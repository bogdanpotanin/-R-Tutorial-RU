# --------
# Потанин Богдан Станиславович
# Введение в R
# Урок 21. Числа с плавающей точкой
# --------

# Экспоненциальная запись (scientific notation) 
# позволяет удобно записывать чрезвычайно большие 
# и малые числа, сохраняя основные разряды
# Запишем одно и то же число
0.0000000000000012300000526     # в обычной записи
1.23e-15                        # в экспоненциальной записи, что
1.23 * (10 ^ (-15))             # эквивалентно такой записи
1231532529726                   # по аналогии для больших чисел
1.231533e+12                    
1.231533 * (10 ^ (12))             

# При помощи функции sprintf() можно написать число
# с произвольным количеством знаков после точки
sprintf("%.9f", 0.000123000987)    # замените 9 или 12 на любое
sprintf("%.12f", 12.000123000987)  # желаемое число знаков
                                   # после точки

# Установим настройки отображения
# чисел в консоли
options(scipen = 999)       # уберем scientific notation
options(digits = 22)        # будем писать в консоли 
                            # ровно 22 знака числа

# Модуль любого целого числа можно представить как 
# сумму двоек, возведенных в целые степени. Получить
# степени можно по следующему алгоритму:
numberToLog2 <- function(x)
{
  x <- abs(x)                            # берем модуль нашего числа, чтобы
                                         # впоследствии использовать данную
                                         # функцию и для отрицательных чисел
  x_to_log2 <- NULL                      # будем хранить степени двойки
                                         # в отдельном векторе
  while (x != 0)                         # пока наше число не станет нулем
  {                                      # или настолько маленьким числом, что
                                         # R не сможет отличить его от нуля
    x_log_2 <- floor(log(x, 2))          # берем целую часть логарифма
                                         # нашего числа по основанию два
    x_to_log2 <- c(x_to_log2, x_log_2)   # сохраняем ее в вектор со
                                         # степенями двойки
    x <- x - 2 ^ x_log_2                 # уменьшаем наше число на 
                                         # на два с соответствующей степени
  }
  
  return(x_to_log2)                      # возвращаем вектор степеней двойки
}
x <- 353                                 # рассмотрим данное число
x_to_log2 <- numberToLog2(x)             # разложим нашем число на
                                         # сумму двоек в степенях,
                                         # возвращаемых функцией
sum(2 ^ x_to_log2)                       # убедимся, что был
sum(2 ^ x_to_log2) == x                  # получен корректный ответ

# Исходя из полученного результата мы можем
# предложить бинарную репрезентацию для
# любого целого положительного числа. Будем
# для этого использовать вектор, где i-й
# элемент c конца указывает на двойку в i-й степени
numberToBinary <- function (x)
{
  x_to_log2 <- numberToLog2(x)                      # получаем степени двойки для
                                                    # бинарной репрезентации x
  x_to_log2_max <- max(x_to_log2)                   # берем наибольшую и            
  x_to_log2_min <- min(x_to_log2)                   # наименьшую степени,
  
  my_binary <- rep(0, x_to_log2_max -               # создаем вектор, в котором
                      x_to_log2_min + 1)            # сохраним 0 для неиспользованных 
                                                    # степеней двойки
  my_binary[x_to_log2 - x_to_log2_min + 1] <- 1     # и 1 для использованных
  
  names(my_binary) <- paste("2 ^ ",                 # присвоим удобные имена
                            x_to_log2_min:          # для элементов вектора
                            x_to_log2_max,       
                            sep = "")
  
  my_binary <- rev(my_binary)                       # в качестве первого элемента при бинарной
                                                    # репрезентации обычно используют наибольшую
                                                    # из степеней, поэтому повернем вектор в
                                                    # обратном порядке, прежде чем вернуть его
                                                    # из функции
  return(my_binary)
}
# Возьмем целое число
x <- 353
x_binary <- numberToBinary(x)                         # получаем бинарную репрезентацию x
sum(2 ^ ((length(x_binary) - 1):0) * x_binary)        # удостоверимся в том, что 
sum(2 ^ ((length(x_binary) - 1):0) * x_binary) == x   # ответ корректный
# Теперь возьмем нецелое число
x <- 353.25257
x_to_log2 <- numberToLog2(x) 
numberToBinary(x)
sum(2 ^ x_to_log2)            # возникает небольшая погрешность, связанная с тем, что
                              # компьютер хранит информацию о любом числе как 
                              # информацию о сумме конечного числа двоек в целых степенях
                              # и запомнить бесконечно много степеней двойки он не может.
                              # Максимальная и минимальная степени двойки, которые компьютер может
                              # учитывать при формировании числа, зависят от типа переменной:
                              # float (single) - от -126 до 127
                              # double - от -1022 до 1023
                              # Quad - от −16382 до 16383
                              # При этом общее число фиксированных степеней, то есть длина
                              # последовательности из ноликов и единичек для каждого
                              # типа фиксирована
                              # В R в подавляющем большинстве случаев 
                              # используется только тип double

# На самом деле бинарная репрезентация числа, используемая
# компьютером, является чуть более сложной. Она состоит из 
# бинарных репрезентация наподобие тех, что были показаны выше.
# Представим число x использую следующие элементы:
# 1. Знак (s) - знак числа x
# 2. Точность (p) - в зависимости от типа равняется
#    максимальной степени двойки, которая может учитываться 
#    при бинарной репрезентации x (см. выше)
# 3. Экспонента (e) - сумма точности и максимальной из 
#    степеней двойки, используемой при бинарной репрезентации x
# 4. Мантисса (m) - результат деления x на разницу
#    экспоненты и точности (см. выше)
# В результате: x = s * 2 ^ (e - p) * m
x <- 353.25257           # рассматриваемое число
s <- sign(x)             # знак числа
p <- 1023                # как для double
e <- floor(log2(x)) + p  # экспонента
m <- x / (2 ^ (e - p))   # мантисса
s * 2 ^ (e - p) * m
# Для представления числа x используется объединение бинарных
# репрезентаций знака (0 для положительных 1 для отрицательных),
# экспоненты (из 11 элементов для double) и мантиссы (из 52 элементов для double).
# При этом, из бинарной репрезентации мантиссы исключают
# первый элемент, так как он всегда равен единице, то есть (2 ^ 0) точно присутствует.

# Напишем функцию, которая будет рассчитывать указанные выше
# компоненты и их бинарную репрезентацию для типа double
numberDoubleValues <- function(x, is_binary = FALSE)
{
  fl <- list("Sign" = ifelse(x > 0, 1, -1),               # определяем знак
             "Exponent" = floor(log2(abs(x))) + 1023,     # считаем экспоненту
             "Mantissa" = abs(x) / 
                          2 ^ floor(log2(abs(x))))        # вычисляем мантиссу
  
  if(is_binary)                                           # если необходимо бинарная
  {                                                       # репрезентация элементов
    fl$Sign <- as.numeric(fl$Sign == (-1))                # будем обозначить отрицательные
                                                          # значения как 1, а положительные как 0
    fl$Exponent <- numberToBinary(fl$Exponent)            # получаем бинарную репрезентацию  
    fl$Exponent <- c(fl$Exponent,                         # скорректированной экспоненты, которая в силу 
                     rep(0, 11 - length(fl$Exponent)))    # накладываемых типом double ограничений должна 
                                                          # содержать ровно 11 элементов и  
    names(fl$Exponent) <- paste("2 ^ ", 10:0, sep = "")   # присваиваем им удобные имена
    fl$Mantissa <- numberToBinary(fl$Mantissa)[-1]        # получаем бинарную репрезентацию 
    fl$Mantissa <- c(fl$Mantissa,                         # мантиссы, которая в силу накладываемых
                     rep(0, 52 - length(fl$Mantissa)))    # типом double ограничений должна содержать
    names(fl$Mantissa) <- paste("2 ^ -", 1:52, sep = "")  # ровно 52 элемента, и присваиваем им 
                                                          # удобные имена
    fl$result <- c(fl$Sign, fl$Exponent, fl$Mantissa)     # общий результат как его 
    names(fl$result) <- NULL                              # видит компьютер (число типа double)
  }
  
  return(fl)
}
x <- 353.25257
r1 <- numberDoubleValues(x)
r2 <- numberDoubleValues(x, TRUE)

# Сделаем функцию, которая из бинарной репрезентации
# будет возвращать конкретное число
binaryToDouble <- function (x)
{
  x_sign <- ifelse(x[1] == 0, 1, -1)                               
  x_exponent <- sum(2 ^ (10:0) * x[2:12])
  x_exponent_adj <- 2 ^ (x_exponent - 1023)
  x_mantissa <- (1 + sum(2 ^ -(1:52) * x[13:64]))
  
  return(x_sign * x_exponent_adj * x_mantissa)
}
binaryToDouble(r2$result)
# Числа, которые использует компьютер, зачастую называют числами
# с плавающей точкой (floating point numbers), где позиция 
# точки (binary point) в мантиссе определяется экспонентой.
# При этом обратите внимание, что все числа с плавающей точкой являются рациональными.
# Поскольку для сохранения информации о числе с плавающей точкой нужно
# использовать (1 + 11 + 52) = 64 значения (0 и 1), то его вес 
# составляет 64 бита (8 байт).

# Получить доступ к различным характеристикам
# компьютера можно при помощи обращения
# к элементам встроенного в R листа .Machine
help(.Machine)

# Машинный эпсилон (machine precision) это наименьшее число x такое,
# что компьютер способен отличить 1 + x от 1. В результате все
# числа от 1 до 1 + x компьютер будет воспринимать как одинаковые.
x <- .Machine$double.eps    # сохраним машинный эпсилон в
                            # отдельную переменную
(1 + x) == 1                # убедимся, что R отличает единицу
(1 + x * 0.5) == 1          # от суммы единицы и машинного нуля, но
                            # не отличает от суммы единицы и 
                            # числа, вдвое меньше машинного нуля
# Также, машинный ноль определяет максимальную относительную ошибку
# при представлении вещественного числа как числа с плавающей точкой
# (|число - аппроксимация| / число) <= x
# То есть для положительных чисел аппроксимация окажется в интервале:
# число * (1 - x) <= аппроксимация <= число * (1 + x)
# В результате любое число и любая его аппроксимация, 
# удовлетворяющие данному неравенству, будут восприниматься 
# компьютером как одинаковые числа. Кроме того, результат любой
# арифметической операции (даже с учетом того, что в ней фигурируют
# не вещественные, а уже преобразованные компьютером числа), 
# компьютер возвращает как некоторую аппроксимацию настоящего
# результата, удовлетворяющую неравенству, указанному выше. 
4.9999999999999998   # аппроксимируется значением 5
3.1234567898765499   # обратите внимание на цифры в
                     # последних разрядах числа
1.0000000000000006 + # получаем аппроксимацию результата
5.0000000000000001   # сложения чисел, отличающуюся от
                     # истинного значения
1.1 * 5.1            # получаем аппроксимацию результата
                     # умножения чисел, отличающуюся от
                     # истинного значения
# В результате при сложении чисел возникает
# погрешность не менее, чем машинный ноль.

# Предельные значения
.Machine$double.xmax                 # максимальное по модулю значение
.Machine$double.xmax + 10 ^ 19       # из-за машинного эпсилона оно не изменяется при
.Machine$double.xmax * 1.00001       # добавлении даже весьма больших
.Machine$double.xmax + 10 ^ (300)    # чисел или умножении
                                     # на крайне малые числа, но превращается
                                     # в бесконечность при добавлении
                                     # достаточно больших чисел или
                                     # умножении даже на весьма малые числа
.Machine$double.xmin                 # наименьшее по модулю значение
# Максимальное число приблизительно
# равняется 2 в 1024 степени
2 ^ 1023.9999999999999
log(.Machine$double.xmax, 2)

# Чтобы повысить точность вычислений можно
# воспользоваться специальным пакетом
install.packages("Rmpfr")
library("Rmpfr")
t1 <- 1.0000000000000006                      # сначала создадим
t2 <- 5.0000000000000001                      # обычные числа
t1_mpfr <- mpfr(x = "1.0000000000000006",     # число.
                precBits = 252)               # точность в битах, которая
t2_mpfr <- mpfr(x = "5.0000000000000001",     # у double составляет 53 бита:
                precBits = 252)               # длина бинарной репрезентации мантиссы + 1.
class(t1_mpfr)                                # эти числа имеют специальный класс
t1_mpfr + t2_mpfr                             # с данными числами можно осуществлять
t1 + t2                                       # базовые арифметические операции с
exp(t1)                                       # повышенной точностью
exp(t1_mpfr)                                  # однако скорость расчетов при этом
pnorm(t1)                                     # будет существенно снижаться
pnorm(t1_mpfr)
dnorm(t1)
dnorm(t1_mpfr)
# Данный пакет поддерживает матрицы и векторы
pnorm(c(t1, t2))
pnorm(c(t1_mpfr, t2_mpfr))
# Сравним скорость расчетов с обычными числами
# и числами повышенной точности
n <- 10000000
system.time(pnorm(rep(t1, n)))
system.time(pnorm(rep(t1_mpfr, n / 500)))

# Обратите внимание, что работать с числами
# повышенной точности могут лишь самые
# базовые функции в R. Например, следующие
# функции делать этого не способны
dt(t1,                  # функция плотности распределения 
   df = 5)              # стьюдента с 5 степенями свободы
                        # в точке t1
dt(t1_mpfr, 5)          # ошибка, поскольку данная функция
                        # не умеет работать с числами
                        # повышенной точности

# Подробней о пакете Rmpfr можно почитать
# перейдя по ссылке ниже:
# https://cran.r-project.org/web/packages/Rmpfr/vignettes/Rmpfr-pkg.pdf

# ЗАДАНИЯ
  # 1. Используя пакет Rmpfr и входящую в него функцию erf() 
  #    самостоятельно напишите аналоги функции pnorm() для 
  #    расчетов функции стандартного нормального распределения
  #    Подсказка: pnorm(x) = (1 + erf(x / sqrt(2))) / 2
{
  pnorm_mpfr <- function(x, precBits = NULL)
  {
    x <- mpfr(x = x,
              precBits = precBits)
    one <- mpfr(x = 1,
                precBits = precBits)
    two <- mpfr(x = 2,
                precBits = precBits)
    cdf <- (one + erf(x / sqrt(two))) / two
    return(cdf)
    
  }
  pnorm_mpfr(1, 100)
}