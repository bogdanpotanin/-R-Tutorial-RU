# --------
# Потанин Богдан Станиславович
# Введение в R :)
# Урок 6. Создание функций
# --------

# Создадим собственную функцию, которая рассчитывает
# скалярное произведение между векторами, а затем
# домножает его на некоторое значение
scalarProduct <- function (x, y, a = 10)
{
  scalar_product <- sum(x * y)               # рассчитываем скалярное произведение
  scalar_product_adj <- scalar_product * a   # и домножим его на число
  return (scalar_product_adj)                # возвращаем полученный результат
}
# где:
  # scalarProduct - название функции
  # x, y, a - аргументы функции
  # a = 10 означает, что по умолчанию (default), если
  # значение a не задано, то оно будет равняться 10
  # то, что расположено между {}, именуется телом функции
  # то, что находится в return(), является
  # возвращаемым объектом (return value)

# Применим созданную функцию к векторам v_1 и v_2
v_1 <- c(8, -3, 5, -1, 6)
v_2 <- c(0, 5, -10, 6, 9)
scalarProduct(x = v_1, y = v_2, a = 5)          # используя произвольное значение для a
scalarProduct(x = v_1, y = v_2)                 # используя значение по умолчанию для a
a <- 3 
x <- c(1, 2, 3, 4, 5)
scalarProduct(x = x, y = v_2, a = a)            # название аргумента и переменной,
                                                # значение которой он принимает, могут
                                                # совпадать

# Создадим новую переменную и присвоим ей
# значение, возвращаемое функцией
z <- scalarProduct(x = v_1, y = v_2, a = 5)

# Названия функций могут быть такими же, как у переменных,
# но как правило название функции начинается с маленькой
# буквы и, если оно включает несколько слов, то каждое
# следующее из них пишется с большой буквы.

# Переменные бывают локальными и глобальными. Локальные
# переменные существуют только внутри некоторой области
# и не изменяются за ее пределами. До этого мы использовали
# только глобальные переменные, но аргументы функции внутри
# тела функции выступают как локальные переменные.
myFunc <- function (g)
{
  g <- g ^ 2 + 5      # за пределами функции аргумент g не изменяется,
                      # поскольку является локальной переменной, а 
                      # значит существует только в теле функции myFunc()
  return (g)
}
myFunc(g = v_1)       # убедимся, что значение вектора v_1 не изменится,
                      # несмотря на то, что внутри функции оно возводилось
                      # в квадрат
g <- c(2, 5, 8)       # изменения не произойдут даже если аргумент функции
myFunc(g = g)         # совпадает по названию с присваиваемой ему переменной
g <- myFunc(g)        # чтобы изменить значение g его необходимо перезаписать

# Переменные в теле функции можно сделать глобальными
# с помощью оператора <<-, однако такой подход используется
# крайне редко и без острой необходимости прибегать к нему 
# настоятельно не рекомендуется

  # ЗАДАНИЯ
    # 1. Создайте функцию, которая возвращает сумму 
    #    двух векторов, деленную на сумму их длин
{
  x <- c(1, 2, 3, 4, 5)
  y <- c(6, 7, 8, 9, 10)
  myFunction1 <- function (x, y)
  {
    new_vector <- (x + y) / (length(x) + length(y))
    return(new_vector)
  }
  myFunction1(x, y)
}
    # 2. Создайте аналогичную функцию для трех векторов
{
  myFunction2 <- function (x, y, z)
  {
    new_vector <- (x + y + z) / 
                  (length(x) + length(y) + length(z))
    return(new_vector)
  }
  z <- c(11, 12, 13, 14, 15)
  myFunction2(x, y, z)
}
    # 3. Используя предыдущую функцию, создайте функцию, 
    #    которая возвращает тот же результат, что и
    #    предыдущая функция, но возведенный в степень g,
    #    которая, по умолчанию, равняется двум
{
  myFunction3 <- function (x, y, z, g = 2)
  {
    fn_output <- myFunction2(x, y, z)
    fn_output <- fn_output ^ g
    return(fn_output)
  }
  myFunction3(x, y, z)
}
    # 4. Напишите функцию, которая возвращает разницу 
    #    между наибольшим и наименьшим значениями вектора
{
  myFunction4 <- function (x)
  {
    my_diff <- max(x) - min(x)
    return(my_diff)
  }
  myFunction4(x)
}
    # 5. Запрограммируйте функцию, которая создает вектор z,
    #    используя элементы вектора x, соответствующие индексам,
    #    указанным в векторе y
{
      myFunction5 <- function (x, y)
      {
        return(x[y])
      }
      myFunction5(c(-5, 15.3, 0.8), c(3,1))
}
    # 6. Придумайте функцию, которая возвращает вектор,
    #    содержащий наибольшее и наименьшее значения вектора,
    #    полученного как произведение двух векторов
{
  myFunction6 <- function (x, y)
  {
    z <- x * y
    t <- c(min(z), max(z))
    return(t)
  }
  myFunction6(c(1, 2, 3), c(4, 5, 6))
}
    # 7. Придумайте функцию, возвращающую произведение двух чисел,
    #    причем первое из них по умолчанию должно равняться двум,
    #    а второе - пяти. Догадайтесь, какое значение вернет
    #    функция, если вы не податите в нее никакие аргументы.
{
  myFunction7 <- function (x = 2, y = 5)
  {
    return(x * y)
  }
  myFunction7(10)
  myFunction7(y = 10)
  myFunction7()
}