# --------
# Потанин Богдан Станиславович
# Введение в R :)
# Урок 14. Сортировка
# --------

# Векторы сортируются при помощи функции sort()
v_1 <- c(3, 5, 1, 9,-6, 15, 1)
sort(v_1)                        # в порядке возрастания
sort(v_1, decreasing = TRUE)     # в порядке убывания

# Для строковых векторов принцип работы такой же, только
# сортировка происходит в алфавитном порядке
s_1 <- c("cat", "dog", "bird", "lion", "fish")
sort(s_1)

# Для логических векторов сначала идут значения FALSE,
# а затем TRUE. Обычно к логическим векторам сортировка
# не применяется
b_1 <- c(TRUE, FALSE, TRUE, FALSE, TRUE)
sort(b_1)

# Научимся сортировать датафреймы
# по определенному столбцу

# Создадим несколько векторов
Names_1 <- c("Sofiya", "Bogdan", 
             "Masha", "Ivan",
             "Boris")
Wage <- c(800, 700, 800, 300, 700)
Animal <- c("cat", "cat", "dog", "cat", "dog")
HasCar <- c(FALSE, FALSE, TRUE, TRUE, FALSE)

# Создадим датафреймы
h <- data.frame("Names" = Names_1,
                "Wage" = Wage,
                "Animal" = Animal,
                "HasCar" = HasCar)

# При помощи функции order() можно вывести индексы
# элементов вектора (не сами значения) по возрастанию 
# или по убыванию соответствующих этим индексам значений
order(v_1)                                # для простоты применим для
v_1[order(v_1)]                           # начала функцию к вектору
Wage_ord_incr <- order(h[, "Wage"])       # по возрастанию
h[Wage_ord_incr, ]                        # проверка
Wage_ord_decr <- order(h[, "Wage"],       # по убыванию
                       decreasing = TRUE)      
h[Wage_ord_decr, ]
h <- h[order(h[, "Wage"]),]               # перезапишем датафрейм с учетом
                                          # сортировки индивидов по зарплате

# Можно сортировать и сразу же по двум переменным.
h$Spendings <- c(800, 320, 560, 250, 1000)
# Сначала датафрейм сортируется по Wage, а затем для
# одинаковых значений Wage элементы датафрейма
# сортируются по Spendings
sort_ind <- order(h[, c("Wage")], h[, c("Spendings")])
h[sort_ind, ]

# Чтобы найти индекс минимального или максимального
# элемента можно использовать функции
which.min(v_1)        # индекс (не значение) минимального элемента
v_1[which.min(v_1)]   # значение минимального элемента
which.max(v_1)        # индекс (не значение) максимального элемента
v_1[which.max(v_1)]   # значение максимального элемента

  # ЗАДАНИЯ
    # 1. Отсортируйте вектор c(1, 2, 3, 4, 5) в обратном порядке
{
  sort(c(1, 2, 3, 4, 5), decreasing = TRUE)
}
    # 2. Создайте функцию, которая сортирует по возрастанию 
    #    датафрейм по значениям столбца с заданным именем
{
  myFunc <- function(x, s)
  {
    if(!any(names(x) == s))
    {
      stop("There is not column s in x")
    }
    
    x <- x[order(x[, s]), ]
    
    return(x)
  }
  d <- data.frame("c1" = c(1, 3, -3, 9, -8, 2),
                  "c2" = c(1, 2, 3, 4, 5, 6),
                  "c3" = c("This", "Is", "Just", 
                            "Some", "Character", "Vector"))
  myFunc(d, "c1")
  myFunc(d, "c2")
  myFunc(d, "c3")
}
    # 3. Отсортируйте датафрейм mtcars по лошадиным силам
    #    автомобиля (столбец hp). Чтобы получить доступ к
    #    датафрейму mtcars используйте help(mtcars)
{
  attach(mtcars)
  mtcars[order(mtcars$hp), ]
}
    # 4. Отсортируйте датафрейм mtcars сначала по числу
    #    цилиндров автомобиля (столбец cyl) и числу передних
    #    колес (столбец gear).
{
      attach(mtcars)
      mtcars[order(mtcars$cyl, mtcars$gear), ]
}
    # 5. Отсортируйте датафрейм mtcars по именам автомобилей, 
    #    для чего вам понадобится функция rownames().
{
  mtcars[order(rownames(mtcars)),]
}
    # 6. При помощи циклов напишите функцию, реализующую алгоритм
    #    сортировки выбором (Selection sort), не используя
    #    встроенную функциюю sort
{
# Можно реализовать данную функцию
# гораздо эффективней, но для
# сохранения ясности кода применим
# менее эффективный вариант
myFunc <- function(x)
  {
    n <- length(x)
    y <- x             # будем сохранять в этот вектор
                       # значения x по возрастанию
    for (i in 1:n)
    {
      min_x_ind <- which.min(x)[1]  # сохраняем первый из индексов,
                                    # соответствующих минимальному
                                    # значению на случай, если
                                    # минимальных значений несколько
      y[i] <- x[min_x_ind]
      x <- x[-min_x_ind]
    }
    
    return(y)
  }
  myFunc(c(3, 7, -2, 5, 1, 15, 1))
}