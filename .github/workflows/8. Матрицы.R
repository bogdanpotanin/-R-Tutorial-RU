# --------
# Потанин Богдан Станиславович
# Введение в R :)
# Урок 8. Матрицы
# --------

# Матрицы как и вектор содержат переменные одного
# и того же типа, но отличаются от векторов тем, 
# что имеют двумерную размерность

# Матрицы, как правило, создаются из
# векторов при помощи функции matrix(),
# со следующими ключевыми аргументами:
#   data - вектор, из которого создается матрица
#   ncol - число строк матрицы
#   nrow - число столбцов матрицы
#   byrow - будет ли новая строка начинаться после
#           каждого ncol-ного элемента вектора,
#           определенного аргументом data
  # Красивый вариант (предпочтителен)
m_1 <- matrix(data = c(2, 5, 7,
                       3, 9, 10, 
                       9, 6, 90),
              nrow = 3, ncol = 3, 
              byrow = TRUE)          # по умолчанию byrow = FALSE,
                                     # так что не забывайте менять
                                     # его на TRUE
  # Краткий вариант (допустим)
m_1 <- matrix(c(2, 5, 7, 3, 9, 10, 9, 6, 90), 3, 3, TRUE)

# При обычном перемножении матрицы умножаются 
# не классическим способом, а поэлементно
  # Создадим еще одну матрицу
m_2 <- matrix(data = c(3, 19, 8, 
                       -20, 3, 15, 
                       6, 17, 33), 
              nrow = 3, ncol = 3, 
              byrow = TRUE)
  # Применим к нашим матрица различные операции
m_1 * m_2            # (i, j)-й элемент матрицы m_1 умножается
                     # на (i, j)-й элемент матрицы m_2
log(m_1)             # по аналогии с векторами log применяется
                     # к каждому элементу матрицы m_1
exp(m_1) + sin(m_2)  # в целом выражения с матрицами работают
                     # по аналогии с аналогичными выражениями
                     # для векторов
m_1 > m_2            # в том числе можно использовать и
                     # логические операторы
# Классическое умножение матриц осуществляется 
# следующим образом при помощи оператора %*%
m_1 %*% m_2

#Чтобы выбрать элемент матрицы, 
# следует написать [номер строки, номер столбца]
m_1[2, 3]            # элемент из второй строки третьего столбца
exp(m_1[2, 3] + 5)   # математическая операция над этим элементом
# как и с векторами можно выбирать сразу несколько строк и столбцов,
# указывая соответствующие индексы
m_1[c(1, 3), c(2, 3)]  # берем подматрицу, состоящую из 2 и 3 строк, а
                       # также 2 и 3 столбцов
# Можно также брать матрицу без определенных строк и столбцов
m_1[-1, -c(1, 2)]      # исключим первый столбец, а
                       # также вторую и третью строки
# Чтобы выбрать весь столбец или всю строку
# достаточно не указывать индекс, при этом
# на выходе вы получите вектор
m_1[, 2]               # берем второй столбец
m_1[, c(1, 3)]         # берем первый и третий столбцы
m_1[2, ]               # берем вторую строку
m_1[, 1] + m_1[, 2]    # сумма первого и второго столбцов

# Чтобы узнать размерность матрицы, 
# можно воспользоваться функцией dim()
m_3 <- matrix(data = c("a", "b", "cat", 
                       "d", "e", "frog"), 
              nrow = 2, ncol = 3, 
              byrow = TRUE)
dim(m_3)
dim(m_3)[1]   # количество строк
dim(m_3)[2]   # количество столбцов

# Чтобы проверить, является ли объект матрицей,
# можно использовать функцию is.matrix()
is.matrix(m_1)                   # матрица является матрицей (очевидно)
is.matrix(m_1[c(1, 2), c(1, 2)]) # подматрица матрицы тоже матрица
is.matrix(m_1[, 1])              # столбец матрицы воспринимается как вектор
is.matrix(m_1[2, ])              # строка матрицы воспринимается как вектор

# Векторы можно преобразовывать в матрицы с
# одним столбцом с помощью функцию as.matrix()
z <- c(1, 2, 3)
z <- as.matrix(z)
as.matrix(m_1[, 1])             # вектор столбец
as.matrix(m_1[2, ])             # тоже вектор столбец (не строка!)

# Важней, чем кажется!
# Чтобы вектор воспринимался как матрица,
# необходимо использовать функцию as.matrix()
dim(m_1[, 1])                       # возвращает NULL, так как функция dim()
                                    # работает с матрицами, а m_1[, 1]
                                    # воспринимается как вектор
dim(as.matrix(m_1[, 1]))            # теперь все работает правильно
dim(as.matrix(m_1[1, ]))            # но здесь вектор ошибочно воспримется
                                    # как вектор столбец, а не строка
as.matrix(m_1[1, ]) %*% m_1         # поэтому здесь вы получаете ошибку
matrix(m_1[1, ], nrow = 1) %*% m_1  # но так работает правильно, поскольку в
                                    # функции matrix() мы создаем из строки 
                                    # m_1[1, ] матрицу с одной строкой
# Если в функцию matrix() подать 
# лишь аргумент nrow или только 
# ncol, то второй аргумент 
# подберется автоматически. Если 
# же подобрать его невозможно, то 
# R выдаст предупреждение и функция
# вернет некорректный результат
matrix(c(1, 2, 3, 4, 5, 6), ncol = 2)  # работает корректно
matrix(c(1, 2, 3, 4, 5, 6), ncol = 4)  # работает не корректно

# Матрицы можно объединять
cbind(m_1, m_2)             # по столбцам (сolumn bind)
rbind(m_1, m_2)             # по строкам (row bind)
cbind(m_1, m_2, m_1)        # причем любое количество, так как
                            # первый аргумент это ..., работающий
                            # по аналогии с тем, что был у рассмотренной
                            # ранее функции paste()
cbind(m_1, m_2[, c(1, 2)])  # работает, так как объединяемые  имеют 
                            # матрицы одинаковое количество строк
cbind(m_1, m_2[c(1, 2), ])  # не работает, так как объединяемые 
                            # матрицы имеют разное количество строк

# Чтобы создать матрицу из одних и тех же значений,
# достаточно вместо вектора прописать одно значение
# и указать размерность
matrix(0, nrow = 3, ncol = 5)   # матрица 3 на 5 из нулей
matrix(NA, 7, 8)                # матрица 7 на 8 из NA
matrix("cat", 7, 8)             # матрица 2 на 2 из "cat"

# Некоторые дополнительные полезные функции
t(m_1)             # транспонирование
det(m_1)           # определитель
isSymmetric(m_1)   # проверка симметричности
solve(m_1)         # обратная матрица

  # ЗАДАНИЯ
    # 1. Создайте следующую матрицу, назвав ее mat_1:
    #    2 5
    #    8 9
    #    3 -10
    #    Найдите произведение числа строк 
    #    этой матрицы на число ее столбцов.
{
  mat_1 <- matrix(c(2, 5,
                    8, 9,
                    3, -10),
                  nrow = 3, ncol = 2,
                  byrow = TRUE)
  # первый способ
  mat_new <- dim(mat_1)[1] * dim(mat_1)[2]
  # второй способ используя функцию prod(),
  # которая перемножает все элементы вектора
  mat_new <- prod(dim(mat_1))  
}
    # 2. Создайте следующую матрицу, назвав ее mat_2:
    #    3 9 3
    #    8 1 15
    #    Найдите произведение матрицы mat_1 на матрицу mat_2
    #    используя определение из линейно алгебры (с помощью %*%).
    #    Затем, найдите произведение транспонированной матрицы mat_2
    #    на подматрицу матрицы mat_1, состоящую из первой и
    #    последней строк.
{
  mat_2 <- matrix(c(3, 9, 3,
                    8, 1, 15),
                  nrow = 2, ncol = 3,
                  byrow = TRUE)
  mat_1 %*% mat_2
  t(mat_2) %*% mat_1[c(1, 3), ]
}
    # 3. Объедините матрицу mat_1 с транспонированной матрицей
    #    mat_2 по столбцам, а затем транспонированную матрицу
    #    mat_1 с матрицей mat_2. Затем, возьмите подматрицу mat_1,
    #    состоящую из ее первых двух строк, и объедините по столбцам
    #    с произвольной подматрицей mat_2
{
  cbind(mat_1, t(mat_2))
  rbind(t(mat_1), mat_2)
  cbind(mat_1[c(1, 2),], mat_2[,c(2, 3)])
}
    # 4. Напишите функцию, которая возвращает TRUE, если матрица
    #    является квадратной и FALSE - в противном случае
{
  myFunc <- function(x)
  {
    x_nrow <- dim(x)[1]
    x_ncol <- dim(x)[2]
    
    return(x_nrow == x_ncol)
  }
  
  myFunc(mat_1)             # не квадратная матрица
  myFunc(mat_1 %*% mat_2)   # квадратная матрица
}
    # 5. В предыдущем пункте проверьте, работает ли ваша функция
    #    корректно, если в качестве аргумента вместо матрицы
    #    подать вектор. Сделайте так, чтобы векторы размерности 1
    #    воспринимались как квадратные матрицы, а остальные векторы
    #    не считались квадратными матрицами
{
  myFunc <- function(x)
  {
    # достаточно добавить строку
    x <- as.matrix(x)
    
    x_nrow <- dim(x)[1]
    x_ncol <- dim(x)[2]
    
    return(x_nrow == x_ncol)
  }
  myFunc(mat_1)             # не квадратная матрица
  myFunc(mat_1 %*% mat_2)   # квадратная матрица
}  
    # 6. Напишите функцию, которая принимает матрицу и аргументы
    #    i и j, возвращая алгебраическое дополнение (i,j)-го
    #    элемента матрицы. При этом, если аргумент i превышает число
    #    строк матрицы или аргумент j превышает число столбцов, то
    #    функция должна выдавать ошибку с помощью функции stop().
    #    Напомним, что определитель матрицы считается с помощью 
    #    функции det().
{
  myFunc <- function(x, i = 1, j = 1)
  {
    x <- as.matrix(x)
    
    x_nrow <- dim(x)[1]
    x_ncol <- dim(x)[2]
    
    if((x_nrow < i) | (x_ncol < j))
    {
      stop("Too large values of i or (and) j arguments")
    }
    
    # дополнительный минор (a,b)
    M_ab <- det(x[-i, -j])
    # алгебраическое дополнение
    A_ab <- (-1) ^ (i + j) * M_ab
    
    return(A_ab)
  }
  
  myFunc(m_1, 3, 2)     # работает
  myFunc(m_1, 3, 5)     # не работает, так как в матрице менее 5 столбцов
}
    # 7. Напишите функцию, которая возвращает сумму первых трех столбов и
    #    последних трех строк матрицы при условии, что матрица является
    #    квадратной и ее размерность превышает 2 на 2 - в противном случае 
    #    функция должна возвращать ошибку с помощью функции stop().
{
  myFunc <- function(x)
  {
    x <- as.matrix(x)
    
    x_nrow <- dim(x)[1]
    x_ncol <- dim(x)[2]
    
    if((x_nrow == x_ncol) & (x_nrow >= 3))
    {
      submat_sum <- x[,c(1, 2, 3)] + 
                    x[c(x_nrow, 
                        x_nrow - 1,
                        x_nrow - 2)]
      
      return(submat_sum)
    }
    
    stop("x is not a square matrix or less then 3x3")
  }
  
  m_3 <- matrix(c(1, 2, 3, 4, 
                  5, 6, 7, 8, 
                  9, 10, 11, 12, 
                  13, 14, 15, 16),
                nrow = 4, ncol = 4,
                byrow = TRUE)
  myFunc(m_3)                    # работает
  myFunc(m_3[c(1, 2), c(1, 2)])  # не работает, так как слишком маленький размер
  myFunc(m_3[, -1])              # не работает, так как не квадратная
}
    # 8. Создайте функцию, аргументами которой являются две матрицы,
    #    а возвращаемым объектом - матрица их произведения (как в линейно алгебре), 
    #    возведенное в третью степень.
    #    При этом, если матрицы имеют размерности, не позволяющие
    #    осуществить перемножение, то функция должна возвращать ошибку с
    #    помощью функции stop(). 
    #    Подсказка: необходимо, чтобы можно было взять произведение не
    #    только этих матриц, но и произведение произведения этих матриц, что
    #    возможно лишь в случае, когда произведение этих матриц является
    #    квадратной матрицей.
{
  myFunc <- function(x, y)
  {
    x_nrow <- dim(x)[1]
    x_ncol <- dim(x)[2]
    
    y_nrow <- dim(y)[1]
    y_ncol <- dim(y)[2]
    
    # Чтобы матрицы x и y перемножались, необходимо,
    # чтобы число столбцов x совпадало с числом
    # строк y. Чтобы (x * y) возводилась в квадрат или
    # иную степень нужно, чтобы (x * y) была квадратной
    # матрицей
    
    if((x_ncol == y_nrow) & (x_nrow == y_ncol))
    {
      mat_pow_3 <- (x %*% y) %*% (x %*% y) %*% (x %*% y)
      return(mat_pow_3)
    }
    
    stop("It is impossible to multiply x by y or (x * y) by (x * y)")
  }
  myFunc(mat_1, mat_2)              # матрицы подходящей размерности
  myFunc(mat_1, mat_2[,c(1, 2)])    # матрицы mat_1 и mat_2[c(1, 2),]
                                    # не перемножаются
}