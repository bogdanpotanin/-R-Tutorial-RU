# --------
# Потанин Богдан Станиславович
# Введение в R :)
# Урок 7. Логические выражения
# --------

# Логические выражения это И, ИЛИ, НЕТ, РАВНО и т.д.
# Логические выражения возвращают переменную типа logical (bool или boolean)
# Она принимает значения TRUE (правда) и FALSE (ложь)
# Создадим логические переменные, принимающие значения ложь и правда
b_1 <- TRUE
b_2 <- FALSE
typeof(b_1)                                # возвращает тип logical, но его называют
                                           # bool, как в других популярных языках
# Основные логические операторы:
  # ! - нет
  # & - и
  # | - или
  # == - равно
  # != - не равно
  # > - больше
  # < - меньше
  # >= - больше или равно
  # <= - меньше или равно
# Посмотрим, как они работают
!b_1           # убедимся, что не истина возвращает ложь
b_1 & b_2      # убедимся, что истина и ложь возвращает ложь
b_1 | b_2      # убедимся, что истина или ложь возвращает истина
b_1 & !b_2     # убедимся, что истина и не ложь возвращает истина
5 > 7          # возвращает ложь, так как 5 меньше, чем 7
5 == 5         # возвращает истину, так как 5 равно 5
3 != 5         # возвращает истину, так как 3 не равно 5
# Рассмотрим более сложное выражение, возвращающее ложь
b_3 <- ((7 > 5) & (((3 + 5) < 2) | ((5 + 5) == 1 )))

# Вектор может состоять из объектов типа bool
b_vec_1 <- c(FALSE, TRUE, 8 > 1)
b_vec_2 <- c(FALSE, FALSE, 5 != 10)
  # логические операции над ними 
  # будут совершаться поэлементно
b_vec_1 & b_vec_2
b_vec_1 | b_vec_2

# Логические операции можно совершать 
# и между векторами поэлементно
v_1 <- c(1, 2, 3)
v_2 <- c(0, 3, 5)
v_1 > v_2
(v_1 * v_2) > (v_1 + v_2)

# Над объектами типа logical (bool) можно проводить
# и арифметические операции, при этом TRUE
# равняется 1, а FALSE равняется 0
TRUE * 3
(3 - TRUE) * 5
FALSE / 8
TRUE + FALSE
(TRUE - 10) * FALSE
v_1 * b_vec_1

# При помощи оператора if() можно выполнить часть 
# кода при соблюдении определенного условия

# Рассмотрим следующий код изменяя значения k
# Например, при значении 3 код не выполнится,
# а при значении 10 выполнится и напишет "YES!"
k <- 10
if (k >= 5)       # если число k больше или равно 5, то выполняется
{                 # код, расположенный между {}
  print("YES!")   # функция print() пишет в консоле свой аргумент
}
# Также можно определить код, который
# выполнится, если условие не соблюдено
if (k >= 5)
{
  print("YES!")
} else {          # else должно быть на одной строке с нижней скобкой if
  print("NO!")
}
# Условия могут быть вложены друг в друга
if (k >= 5)
{
  print("YES!")
  if(k > 9)
  {
    print("k is greater than 9")
  } else {
    print("k equals or less than 9")
  }
} else {
  print("NO!")
}

# Создадим функцию, которая принимает два вектора и
# складывает их если они являются численными и
# объединяет их как векторы со строками если векторы
# являются строками. Если же векторы имеют разный тип,
# то функция возвращает ошибку.
myFunc <- function(x, y)
{
  # Обычно переменные типа logical (bool)
  # называют с приставкой is_
  
  # Проверяем, являются ли x и y векторами
  # с элементами типа character()
  is_x_character <- is.character(x)        # функция is.character() возвращает true,
  is_y_character <- is.character(y)        # если ее аргумент или имеет тип character
  
  # Проверяем, являются ли x и y векторами
  # с элементами типа double()
  is_x_double <- is.double(x)              # функция is.double() возвращает true,
  is_y_double <- is.double(y)              # если ее аргумент или имеет тип double
  

  if(is_x_character & is_y_character) # если x и y имеют тип character, то
  {                                   # возвращаем объединение строк,
    return_value <- paste(x, y)       # содержащихся в этих векторах
    return (return_value)             # как только функция доходит до
                                      # return() ее выполнение заканчивается,
                                      # возвращается соответствующий объект
                                      # из функции и дальнейший код не выполняется
  } else {                            # в противном случае проверяем,
    if(is_x_double & is_y_double)     # имеют ли векторы x и y тип double
    {                                 # и если это так, то возвращаем
      return_value <- x + y           # сумму векторов x и y
      return (return_value)
    }
  }
  
  # Если код дошел до сюда, то это значит, что
  # x и y имеют разный тип, поэтому вернем ошибку
  # с поясняющим текстом
  stop ("both x and y should be either character or double")
}
v_1 <- c(1, 2, 3)
v_2 <- c(3, 4, 5)
s_1 <- c("a", "b", "c")
s_2 <- c("d", "f", "g")
myFunc(s_1, s_2)           # получаем поэлементное объединение 
                           # векторов со строками
myFunc(v_1, v_2)           # получаем сумму векторов
myFunc(s_1, v_2)           # получаем ошибку

# Функции all() и any() позволяют проверить, являются
# ли все элементы логического вектора TRUE и является ли
# хотя бы один из них TRUE
all(c(TRUE, FALSE, TRUE))    # FALSE, потому что есть один FALSE 
all(c(TRUE, TRUE, TRUE))     # TRUE, потому что все TRUE
any(c(TRUE, FALSE, TRUE))    # TRUE, потому что есть хотя бы один TRUE
any(c(FALSE, FALSE, FALSE))  # FALSE, потому что все FALSE

  # ЗАДАНИЯ
    # 1. При помощи R проверьте, что больше (126 / 3) или (235 / 5)
{
  (126 / 3) > (235 / 5)
}
    # 2. Создайте векторы c(TRUE, FALSE, FALSE) и c(FALSE, TRUE, FALSE).
    #    При помощи использования логических операторов в отношении этих
    #    двух векторов создайте векторы:
    #       a) c(FALSE, TRUE, TRUE)
    #       b) c(FALSE, FALSE, TRUE)
    #       c) c(TRUE, TRUE, FALSE)
    #       d) c(FALSE, FALSE, FALSE)
    #       e) c(TRUE, TRUE, TRUE)
{
  bv_1 <- c(TRUE, FALSE, FALSE)
  bv_2 <- c(FALSE, TRUE, FALSE)
  !bv_1                           # a)
  bv_1 == bv_2                    # b)
  bv_1 | bv_2                     # c)
  bv_1 & bv_2                     # d)
  !(bv_1 & bv_2)                  # e) 
}
    # 3. Напишите функцию, которая возвращает наибольшее значение вектора, если
    #    его длина больше трех и наименьшее значение - в противном случае
{
  myFunc <- function(x)
  {
    if(length(x) > 3)
    {
      return(max(x))
    }
    
    return(min(x))
  }
  myFunc(c(1, 2))
  myFunc(c(1, 2, 3, 4, 5))
}
    # 4. Напишите функцию, которая объединяет две строки (character) таким образом,
    #    что более длинная из них идет сначала, а более короткая - потом.
    #    Если же строки одинаковой длины, то сначала идет первая строка,
    #    а затем - вторая. Длину строки можно узнать с помощью функции nchar()
{
  myFunc <- function(x, y)
  {
    # сохраним длины векторов
    x_n <- nchar(x)
    y_n <- nchar(y)
    
    # в зависимости от условия
    # объединим векторы в
    # определенном
    if(x_n >= y_n)
    {
      return(paste(x, y))
    } else {
      return(paste(y, x))
    }
  }
  # Проверка
    # создаем переменные
  st_1 <- "Short string"
  st_2 <- "Medimum string"
  st_3 <- "The longest string"
    # проверяем функцию
  myFunc(st_1, st_2)
  myFunc(st_3, st_2)
  myFunc(st_3, st_1)
}
    # 5. Напишите функцию, которая определяет число TRUE в векторе из
    #    объектов с типом bool. Обратите внимание, что TRUE воспринимается
    #    в R как 1
{
  myFunc <- function(x)
  {
    return(sum(x))
  }
  myFunc(c(TRUE, FALSE, TRUE))
}
    # 6. Используя результат, полученный в предыдущей задаче, напишите функцию,
    #    которая возвращает число попарно одинаковых элементов в двух векторах.
    #    Например, для векторов c(1, 2, 3) и c(1, 5, 3) число таких элементов
    #    будет 2, а для векторов c(3, 5, 8, 9, 3) и c(6, 5, 8, 9, 10) будет 3
{
  myFunc <- function(x, y)
  {
    return(sum(x == y))
  }
  myFunc(c(1, 2, 3), c(1, 5, 3))
}
    # 7. Напишите собственные аналоги функций all() и any(),
    #    используя только функцию sum()
{
  my_all <- function(x)
  {
    return(sum(x) == length(x))
  }
  
  my_all(c(TRUE, FALSE, TRUE))
  my_all(c(TRUE, TRUE, TRUE))
  
  my_any <- function(x)
  {
    return(sum(x) > 0)
  }
  
  my_any(c(TRUE, FALSE, TRUE))
  my_any(c(FALSE, FALSE, FALSE))
}